# NOTE: It's not ready for use. The OxO and OLS4 API cannot provide the metadata for the symptom ontology. So we need to find another way to fetch the metadata.

import re
import time
import logging
import requests
import pandas as pd
from pathlib import Path
from typing import Any, Union, List, Optional, Dict
from tenacity import retry, stop_after_attempt, wait_random
from ontology_matcher.ontology_formatter import (
    OntologyType,
    Strategy,
    ConversionResult,
    FailedId,
    OntologyBaseConverter,
    BaseOntologyFormatter,
    NoResultException,
)
from ontology_matcher.apis import OLS4Query
from ontology_matcher.symptom.custom_types import SymptomOntologyFileFormat

# SYMP: Symptom Ontology ID, https://raw.githubusercontent.com/SymptomOntology/SymptomOntology/v2022-11-30/src/ontology/symp.owl; https://bioportal.bioontology.org/ontologies/SYMP
# UMLS: Unified Medical Language System, https://www.nlm.nih.gov/research/umls/
# MESH: Medical Subject Headings, https://www.nlm.nih.gov/mesh/
# HP: Human Phenotype Ontology, https://hpo.jax.org/app/

logger = logging.getLogger("ontology_matcher.symptom")

SYMPTOM_DICT = OntologyType(
    type="Symptom", default="UMLS", choices=["SYMP", "MESH", "UMLS", "HP"]
)


class SymptomOntologyConverter(OntologyBaseConverter):
    """Convert the symptom id to a standard format for the knowledge graph."""

    def __init__(
        self, ids, strategy=Strategy.MIXTURE, batch_size: int = 300, sleep_time: int = 3
    ):
        """Initialize the Symptom class for id conversion.

        Args:
            ids (List[str]): A list of symptom ids (Currently support SYMP, UMLS and MESH).
            strategy (Strategy, optional): The strategy to keep the results. Defaults to Strategy.MIXTURE, it means that the results will mix different database ids.
            batch_size (int, optional): The batch size for each request. Defaults to 300.
            sleep_time (int, optional): The sleep time between each request. Defaults to 3.
        """
        super().__init__(
            ontology_type=SYMPTOM_DICT,
            ids=ids,
            strategy=strategy,
            batch_size=batch_size,
            sleep_time=sleep_time,
        )

        # More details on the database_url can be found here: https://www.ebi.ac.uk/spot/oxo/index
        self._database_url = "https://www.ebi.ac.uk/spot/oxo/api/search"
        logger.info("The formatter will use the OXO API to convert the symptom ids.")

    @property
    def ontology_links(self) -> Dict[str, str]:
        return {
            "UMLS": "https://www.nlm.nih.gov/research/umls/",
            "MESH": "https://www.nlm.nih.gov/mesh/",
            "SYMP": "https://bioportal.bioontology.org/ontologies/SYMP",
            "HP": "https://hpo.jax.org/app/",
        }

    def check_batch_size(self):
        """Check the batch size."""
        self.default_check_batch_size()

    def _format_response(self, response: dict, batch_ids: List[str]) -> tuple[List[Dict[str, Any]], List[FailedId]]:
        """Format the response from the OXO API.

        Args:
            response (dict): The response from the OXO API. It was generated by the resp.json() method.
            batch_ids (List[str]): The list of ids for the current batch.

        Raises:
            Exception: If no results found.

        Returns:
            None
        """
        search_results = response.get("_embedded", {}).get("searchResults", [])
        converted_id_dicts: List[Dict[str, Any]] = []
        failed_ids: List[FailedId] = []

        if len(search_results) == 0:
            logger.debug("No results found, we will try to fetch the data again.")
            raise NoResultException()

        for index, id in enumerate(batch_ids):
            prefix, value = id.split(":")
            if prefix not in self.databases:
                failed_id = FailedId(
                    idx=index,
                    id=id,
                    reason="Invalid prefix, only support %s" % self.databases,
                )
                failed_ids.append(failed_id)
                continue

            result = search_results[index] if len(search_results) > 0 else {}
            mapping_response_list = result.get("mappingResponseList", [])
            if len(mapping_response_list) == 0:
                failed_id = FailedId(idx=index, id=id, reason="No results found")
                failed_ids.append(failed_id)
                continue
            else:
                converted_id_dict = {}
                converted_id_dict["idx"] = index
                converted_id_dict[prefix] = id
                converted_id_dict["raw_id"] = id
                # OxO don't provide any metadata for the disease ontology. So we will update the metadata later by using the OLS API.
                converted_id_dict["metadata"] = None
                difference = [x for x in self.databases if x != prefix]
                for choice in difference:
                    # The prefix maybe case insensitive, such as MeSH:D015161. But we need to keep all the prefix in upper case.
                    matched = list(
                        filter(
                            lambda x: re.match(
                                r"^%s.*" % choice, x.get("curie"), re.I.IGNORECASE
                            ),
                            mapping_response_list,
                        )
                    )
                    if len(matched) > 0:
                        converted_ids = [
                            f'{choice}:{x.get("curie").split(":")[1]}' for x in matched
                        ]
                        converted_id_dict[choice] = converted_ids

                        if choice == self.default_database and len(converted_ids) > 1:
                            failed_id = FailedId(
                                idx=index, id=id, reason="Multiple results found"
                            )
                            failed_ids.append(failed_id)
                            # Abandon the converted_id_dict, otherwise the converted_ids will be added to the converted_ids list.
                            converted_id_dict = {}
                            break

                        if self._strategy == Strategy.UNIQUE and len(converted_ids) > 1:
                            failed_id = FailedId(
                                idx=index,
                                id=id,
                                reason="The strategy is unique, but multiple results found",
                            )
                            failed_ids.append(failed_id)
                            # Abandon the converted_id_dict, otherwise the converted_ids will be added to the converted_ids list.
                            converted_id_dict = {}
                            break
                    else:
                        converted_id_dict[choice] = None

                if converted_id_dict:
                    converted_id_dicts.append(converted_id_dict)

        logger.debug("The converted_id_dicts: %s" % converted_id_dicts)
        logger.debug("The failed_ids: %s" % failed_ids)
        return converted_id_dicts, failed_ids

    def _fetch_ids(self, ids) -> dict:
        """Fetch the ids from the OXO API.

        Args:
            ids (List[str]): A list of ids.

        Returns:
            dict: The response from the OXO API which was generated by the resp.json() method.
        """
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36",
        }
        payload = {
            "ids": ids,
            "inputSource": None,
            "mappingTarget": self.databases,
            "mappingSource": self.databases,
            "distance": 1,
        }

        results = requests.post(
            self._database_url,
            headers=headers,
            json=payload,
            params={"size": self._batch_size},
        )

        logger.debug("Requests: %s\n%s" % (results.json(), payload))
        return results.json()

    @retry(stop=stop_after_attempt(15), wait=wait_random(min=1, max=15))
    def _fetch_format_data(self, ids: List[str]) -> tuple[List[Dict[str, Any]], List[FailedId]]:
        """Fetch and format the ids.

        Args:
            ids (List[str]): A list of ids.

        Returns:
            None
        """
        response = self._fetch_ids(ids)
        return self._format_response(response, ids)

    def convert(self) -> ConversionResult:
        """Convert the ids to different databases.

        Returns:
            ConversionResult: The results of id conversion.
        """
        # Cannot use the parallel processing, otherwise the index order will not be correct.
        for i in range(0, len(self._ids), self._batch_size):
            logger.info(
                "Start to convert the disease ids: %s-%s/%s"
                % (i, i + self._batch_size, len(self._ids))
            )
            batch_ids = self._ids[i : i + self._batch_size]
            converted_id_dicts, failed_ids = self._fetch_format_data(batch_ids)
            self.add_failed_ids(failed_ids)
            converted_ids = self.id_dicts2converted_ids(converted_id_dicts)
            updated_converted_ids = OLS4Query.update_metadata(
                converted_ids, self.default_database
            )
            self.add_converted_ids(updated_converted_ids)

            logger.info(
                "Finish convert %s-%s/%s\n\n"
                % (i, i + self._batch_size, len(self._ids))
            )
            time.sleep(self._sleep_time)

        return ConversionResult(
            ids=self._ids,
            strategy=self._strategy,
            converted_ids=self._converted_ids,
            databases=self._databases,
            default_database=self._default_database,
            database_url=self._database_url,
            failed_ids=self._failed_ids,
        )


class SymptomOntologyFormatter(BaseOntologyFormatter):
    """Format the symptom ontology file."""

    def __init__(
        self,
        filepath: Union[str, Path],
        conversion_result: Optional[ConversionResult] = None,
        **kwargs,
    ) -> None:
        """Initialize the SymptomOntologyFormatter class.

        Args:
            filepath (Union[str, Path]): The path of the symptom ontology file. Only support csv and tsv file.
            conversion_result (ConversionResult, optional): The results of id conversion. Defaults to None.
            **kwargs: The keyword arguments for the Symptom class.
        """
        super().__init__(
            filepath,
            file_format_cls=SymptomOntologyFileFormat,
            ontology_converter=SymptomOntologyConverter,
            conversion_result=conversion_result,
            ontology_type=SYMPTOM_DICT,
            **kwargs,
        )

    def format_by_metadata(
        self, new_row: Dict[str, Any], metadata: Dict[str, Any]
    ) -> Dict[str, Any]:
        new_row = self.default_format_by_metadata(new_row, metadata)

        return new_row

    def format(self):
        """Format the symptom ontology file.

        Returns:
            self: The SymptomOntologyFormatter instance.
        """
        self.default_format()


if __name__ == "__main__":
    ids = [
        "SYMP:0000099",
        "SYMP:0000259",
        "SYMP:0000729",
        "MESH:D000006",
        "MESH:D000270",
        "MESH:D000326",
        "MESH:D000334",
    ]
    symptom = SymptomOntologyConverter(ids)
    result = symptom.convert()
    print(result)
